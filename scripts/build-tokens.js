#!/usr/bin/env node

import fs from 'node:fs';
import path from 'node:path';

const projectRoot = process.cwd();
const outputJsPath = path.join(projectRoot, 'src', 'design-tokens.js');
const outputDtsPath = path.join(projectRoot, 'src', 'design-tokens.d.ts');

const sourceCandidates = [
  'tokens3.json',
  'tokens.json',
  path.join('src', 'tokens3.json'),
  path.join('src', 'tokens.json'),
];

const sourceRelativePath = sourceCandidates.find((candidate) =>
  fs.existsSync(path.join(projectRoot, candidate)),
);

const sourcePath = sourceRelativePath
  ? path.join(projectRoot, sourceRelativePath)
  : null;

const dtsContents = `/**
 * VCA Design Tokens Type Declarations
 * Auto-generated by scripts/build-tokens.js
 */

export declare const vcaColors: Record<string, unknown>;
export declare const vcaColorsMeta: Record<string, unknown>;
export declare const vcaSpacing: Record<string, unknown>;
export declare const vcaSpacingMeta: Record<string, unknown>;
export declare const vcaRadius: Record<string, unknown>;
export declare const vcaRadiusMeta: Record<string, unknown>;
`;

const normalize = (raw) => {
  if (!raw || typeof raw !== 'object') {
    throw new Error('Token source must be a JSON object.');
  }

  const input = raw;
  const hasVcaShape =
    'vcaColors' in input || 'vcaSpacing' in input || 'vcaRadius' in input;
  const hasGenericShape =
    'colors' in input || 'spacing' in input || 'radius' in input;

  if (!hasVcaShape && !hasGenericShape) {
    return {
      vcaColors: {},
      vcaColorsMeta: {},
      vcaSpacing: {},
      vcaSpacingMeta: {},
      vcaRadius: {},
      vcaRadiusMeta: {},
    };
  }

  return {
    vcaColors: hasVcaShape ? input.vcaColors ?? {} : input.colors ?? {},
    vcaColorsMeta: hasVcaShape ? input.vcaColorsMeta ?? {} : input.colorsMeta ?? {},
    vcaSpacing: hasVcaShape ? input.vcaSpacing ?? {} : input.spacing ?? {},
    vcaSpacingMeta: hasVcaShape ? input.vcaSpacingMeta ?? {} : input.spacingMeta ?? {},
    vcaRadius: hasVcaShape ? input.vcaRadius ?? {} : input.radius ?? {},
    vcaRadiusMeta: hasVcaShape ? input.vcaRadiusMeta ?? {} : input.radiusMeta ?? {},
  };
};

if (!sourcePath) {
  const hasCheckedInOutputs =
    fs.existsSync(outputJsPath) && fs.existsSync(outputDtsPath);

  if (hasCheckedInOutputs) {
    console.log(
      '[build:tokens] No token JSON source found. Using checked-in src/design-tokens.js and src/design-tokens.d.ts.',
    );
    process.exit(0);
  }

  console.error(
    '[build:tokens] No token JSON source found and no checked-in token outputs exist.',
  );
  console.error(
    '[build:tokens] Add tokens3.json (or src/tokens3.json) and run npm run build:tokens again.',
  );
  process.exit(1);
}

let parsed;
try {
  parsed = JSON.parse(fs.readFileSync(sourcePath, 'utf8'));
} catch (error) {
  console.error('[build:tokens] Failed to parse token source JSON.');
  console.error(error);
  process.exit(1);
}

const tokens = normalize(parsed);

const jsContents = `/**
 * VCA Design Tokens
 *
 * Auto-generated from ${sourceRelativePath}
 * DO NOT EDIT THIS FILE MANUALLY
 *
 * To regenerate: npm run build:tokens
 */

export const vcaColors = ${JSON.stringify(tokens.vcaColors, null, 2)};

export const vcaColorsMeta = ${JSON.stringify(tokens.vcaColorsMeta, null, 2)};

export const vcaSpacing = ${JSON.stringify(tokens.vcaSpacing, null, 2)};

export const vcaSpacingMeta = ${JSON.stringify(tokens.vcaSpacingMeta, null, 2)};

export const vcaRadius = ${JSON.stringify(tokens.vcaRadius, null, 2)};

export const vcaRadiusMeta = ${JSON.stringify(tokens.vcaRadiusMeta, null, 2)};
`;

fs.mkdirSync(path.dirname(outputJsPath), { recursive: true });
fs.mkdirSync(path.dirname(outputDtsPath), { recursive: true });
fs.writeFileSync(outputJsPath, jsContents, 'utf8');
fs.writeFileSync(outputDtsPath, dtsContents, 'utf8');

console.log(`[build:tokens] Built tokens from ${sourceRelativePath}.`);
console.log('[build:tokens] Wrote src/design-tokens.js and src/design-tokens.d.ts.');
